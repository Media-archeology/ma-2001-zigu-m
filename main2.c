#include <osbind.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Player sprite data */
#define PLAYER_W 32
#define PLAYER_H 32

static const unsigned short player_palette[16] = {
    0x0000,
    0x0111,
    0x0040,
    0x0500,
    0x0776,
    0x0755,
    0x0777,
    0x0300,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
};

static const unsigned char player_data[512] = {
    0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
    0x18, 0x60, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00,
    0x10, 0x3F, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0xFC, 0x7C, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00,
    0x3C, 0x70, 0x00, 0x00, 0x03, 0x8F, 0x00, 0x00, 0x02, 0xFC, 0x00, 0x00, 0xFD, 0x38, 0x00, 0x00,
    0x3E, 0xC0, 0x00, 0x00, 0x1D, 0x3F, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 0xFC, 0x70, 0x00, 0x00,
    0x3F, 0x80, 0x00, 0x00, 0x1E, 0x7F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xFF, 0x30, 0x00, 0x00,
    0x3E, 0x00, 0x00, 0x00, 0x0D, 0xFF, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0xFF, 0xA0, 0x00, 0x00,
    0x1E, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00,
    0x04, 0x18, 0x00, 0x00, 0x03, 0xE7, 0x00, 0x00, 0x0C, 0x20, 0x00, 0x00, 0xF3, 0xC0, 0x00, 0x00,
    0x04, 0x18, 0x00, 0x03, 0x03, 0xE7, 0x00, 0x00, 0x0C, 0x20, 0xC0, 0x00, 0xF3, 0xC0, 0x00, 0x00,
    0x04, 0x01, 0x00, 0x02, 0x03, 0xFE, 0x00, 0x00, 0x80, 0x20, 0x60, 0x00, 0x7F, 0xC0, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x07, 0x01, 0xFF, 0x00, 0x00, 0x80, 0x60, 0x70, 0x00, 0x7F, 0x80, 0x00, 0x00,
    0x02, 0x01, 0x00, 0x06, 0x01, 0xFE, 0x00, 0x00, 0x40, 0xC0, 0xB0, 0x00, 0xBF, 0x00, 0x00, 0x00,
    0x03, 0x80, 0x00, 0x03, 0x00, 0x7F, 0x00, 0x00, 0x03, 0x80, 0xE0, 0x00, 0xFC, 0x00, 0x00, 0x00,
    0x02, 0x70, 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
    0x02, 0x1F, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0xF8, 0x60, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x07, 0x00, 0xFF, 0x00, 0x00, 0x80, 0x60, 0x70, 0x00, 0x7F, 0x80, 0x00, 0x00,
    0x01, 0x81, 0x00, 0x06, 0x00, 0x7E, 0x00, 0x00, 0xC0, 0xC0, 0xB0, 0x00, 0xBF, 0x00, 0x00, 0x00,
    0x00, 0xC3, 0x00, 0x05, 0x00, 0x3D, 0x00, 0x00, 0xE1, 0x80, 0xD0, 0x00, 0xDE, 0x00, 0x00, 0x00,
    0x00, 0x41, 0x00, 0x06, 0x00, 0x3E, 0x00, 0x00, 0xC1, 0x00, 0xB0, 0x00, 0xBE, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x03, 0x00, 0x3F, 0x00, 0x00, 0x81, 0x00, 0x60, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x00, 0x01, 0x00, 0x1F, 0x00, 0x00, 0x03, 0x00, 0xC0, 0x00, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x2F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x31, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Block sprite data */
#define BLOCK_W 16
#define BLOCK_H 16
static const unsigned short block_palette[16] = {
    0x0000,
    0x0111,
    0x0040,
    0x0500,
    0x0776,
    0x0755,
    0x0777,
    0x0300,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
};

static const unsigned char block_data[128] = {
    0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x78, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x0F, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x39, 0xF8, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFC, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0xFC, 0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x77, 0xBC, 0x37, 0xB8, 0x08, 0x40, 0x00, 0x00,
    0x7F, 0xFC, 0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xFC, 0x1E, 0xF8, 0x01, 0x00, 0x00, 0x00,
    0x3F, 0xFC, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xDC, 0x07, 0xD8, 0x00, 0x20, 0x00, 0x00,
    0x0F, 0xFC, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF8, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


#define GAMEOVER_W 32
#define GAMEOVER_H 32

static const unsigned short gameover_palette[16] = {
    0x0000,
    0x0111,
    0x0040,
    0x0500,
    0x0776,
    0x0755,
    0x0777,
    0x0300,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
    0x0000,
};

static const unsigned char gameover_data[512] = {
    0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x30, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x01, 0x8E, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
    0x06, 0x18, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00,
    0x04, 0x0F, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00,
    0x0F, 0x1C, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0xFF, 0x4E, 0x00, 0x00,
    0x0F, 0xB0, 0x00, 0x00, 0x07, 0x4F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x1C, 0x00, 0x00,
    0x0F, 0xE0, 0x00, 0x00, 0x07, 0x9F, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0xFF, 0xCC, 0x00, 0x00,
    0x0F, 0x80, 0x00, 0x00, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0xFF, 0xE8, 0x00, 0x00,
    0x07, 0x80, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0xFF, 0xE0, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00,
    0x0F, 0x06, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0xFC, 0xF0, 0x00, 0x00,
    0x09, 0x06, 0x06, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x03, 0x08, 0xF0, 0x00, 0xFC, 0xF0, 0x00, 0x00,
    0x78, 0xF0, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x60, 0x08, 0x98, 0x00, 0x9F, 0xF0, 0x00, 0x00,
    0x60, 0x30, 0x1F, 0xC1, 0x00, 0x0F, 0x00, 0x00, 0x20, 0x18, 0xDC, 0x00, 0xDF, 0xE0, 0x00, 0x00,
    0x73, 0xF0, 0x0C, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x50, 0x30, 0xAC, 0x00, 0xAF, 0xC0, 0x00, 0x00,
    0xFF, 0xF8, 0x21, 0xE0, 0x00, 0x07, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0xFF, 0xFC, 0x7F, 0xF0, 0x00, 0x03, 0x00, 0x00, 0x03, 0xF8, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00,
    0xEF, 0x7F, 0x6F, 0x70, 0x10, 0x80, 0x00, 0x00, 0xFE, 0x18, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
    0xFF, 0xF8, 0x7F, 0xF1, 0x00, 0x07, 0x00, 0x00, 0x20, 0x18, 0xDC, 0x00, 0xDF, 0xE0, 0x00, 0x00,
    0xFD, 0xF8, 0x3D, 0xF1, 0x02, 0x07, 0x00, 0x00, 0x70, 0x30, 0xAC, 0x00, 0xAF, 0xC0, 0x00, 0x00,
    0x7F, 0xF8, 0x1F, 0xF1, 0x00, 0x07, 0x00, 0x00, 0xF8, 0x60, 0x74, 0x00, 0x77, 0x80, 0x00, 0x00,
    0x3F, 0xB8, 0x0F, 0xB1, 0x00, 0x47, 0x00, 0x00, 0x70, 0x40, 0xAC, 0x00, 0xAF, 0x80, 0x00, 0x00,
    0x1F, 0xF8, 0x03, 0xE0, 0x00, 0x07, 0x00, 0x00, 0x20, 0x40, 0xD8, 0x00, 0xDF, 0x80, 0x00, 0x00,
    0x07, 0xF8, 0x00, 0xE0, 0x00, 0x07, 0x00, 0x00, 0x00, 0xC0, 0x70, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x01, 0xFC, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200
#define MAX_BLOCKS 5
#define BLOCK_SPEED 2

typedef struct {
    int x, y;
    int active;
} Block;

typedef struct {
    int x, y;
} Player;

typedef enum {
    STATE_INTRO,       // 게임 설명 페이지
    STATE_START,       // 시작 화면
    STATE_PLAYING,        // 게임 플레이
    STATE_GAMEOVER,    // 게임오버
    STATE_CREDIT       // 크레딧 페이지
} GameState; 

/* 더블 버퍼링용 */
unsigned char *physScreen;
unsigned char *logScreen;
unsigned char buffer[32000];

Player player;
Block blocks[MAX_BLOCKS];
GameState gameState = STATE_INTRO;
int score = 0;
unsigned long frameCount = 0;
unsigned short oldPalette[16];

/* Atari ST 시스템 폰트 (8x8) */
static const unsigned char font_data[256][8] = {
    [32] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
    [48] = {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},  // 0
    [49] = {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00},  // 1
    [50] = {0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00},  // 2
    [51] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},  // 3
    [52] = {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},  // 4
    [53] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},  // 5
    [54] = {0x3C,0x60,0x60,0x7C,0x66,0x66,0x3C,0x00},  // 6
    [55] = {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},  // 7
    [56] = {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},  // 8
    [57] = {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},  // 9

    // A-Z
    [65] = {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // A
    [66] = {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00}, // B
    [67] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00}, // C
    [68] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00}, // D
    [69] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00}, // E
    [70] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00}, // F
    [71] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00}, // G
    [72] = {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    [73] = {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
    [74] = {0x1E,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38}, // J
    [75] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00}, // K
    [76] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // L
    [77] = {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00}, // M
    [78] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00}, // N
    [79] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // O
    [80] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00}, // P
    [81] = {0x3C,0x66,0x66,0x66,0x6E,0x6C,0x36,0x00}, // Q
    [82] = {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00}, // R
    [83] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00}, // S
    [84] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00}, // T
    [85] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // U
    [86] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    [87] = {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
    [88] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00}, // X
    [89] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00}, // Y
    [90] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}, // Z

    // a-z
    [97] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00}, // a
    [98] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b
    [99] = {0x00,0x00,0x3C,0x60,0x60,0x66,0x3C,0x00}, // c
    [100] = {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00}, // d
    [101] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    [102] = {0x0E,0x18,0x18,0x3E,0x18,0x18,0x18,0x00}, // f
    [103] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C}, // g
    [104] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h
    [105] = {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    [106] = {0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x6C,0x38}, // j
    [107] = {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00}, // k
    [108] = {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    [109] = {0x00,0x00,0x6E,0x7F,0x7F,0x6B,0x63,0x00}, // m
    [110] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
    [111] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    [112] = {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60}, // p
    [113] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06}, // q
    [114] = {0x00,0x00,0x6C,0x76,0x60,0x60,0x60,0x00}, // r
    [115] = {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
    [116] = {0x18,0x18,0x3E,0x18,0x18,0x18,0x0E,0x00}, // t
    [117] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u
    [118] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    [119] = {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
    [120] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x
    [121] = {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C}, // y
    [122] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}  // z
};

void setPalette(const unsigned short *palette) {
    int i;
    for (i = 0; i < 16; i++) {
        Setcolor(i, palette[i]);
    }
}

void savePalette() {
    int i;
    for (i = 0; i < 16; i++) {
        oldPalette[i] = Setcolor(i, -1);
    }
}

void restorePalette() {
    int i;
    for (i = 0; i < 16; i++) {
        Setcolor(i, oldPalette[i]);
    }
}

void setupGamePalette() {
    unsigned short gamePalette[16];
    
    /* 기존 16색 팔레트 초기화 */
    for(int i=0;i<16;i++) gamePalette[i] = 0x0000;

    /* 새 RGB 색상 적용 */
    gamePalette[0] = 0x0000;  /* 0: 검정 */
    gamePalette[1] = 0x0322;  /* 1: 52,46,46 */
    gamePalette[2] = 0x0E0;   /* 2: 7,144,0 */
    gamePalette[3] = 0xA00;   /* 3: 182,0,0 */
    gamePalette[4] = 0xFFD;   /* 4: 255,252,213 */
    gamePalette[5] = 0xFAC;   /* 5: 254,169,188 */
    gamePalette[6] = 0xFFF;   /* 6: 255,255,255 */
    gamePalette[7] = 0x700;   /* 7: 124,11,15 */
    
    /* 나머지 팔레트는 검정으로 유지 */
    gamePalette[8] = 0x0000;
    gamePalette[9] = 0x0000;
    gamePalette[10] = 0x0000;
    gamePalette[11] = 0x0000;
    gamePalette[12] = 0x0000;
    gamePalette[13] = 0x0000;
    gamePalette[14] = 0x0000;
    gamePalette[15] = 0xFFF;

    setPalette(gamePalette);
}

void clearBuffer() {
    memset(buffer, 0, 32000);
}

void swapBuffers() {
    /* 버퍼 내용을 물리 화면으로 복사 */
    memcpy(physScreen, buffer, 32000);
}

void drawPlanarSprite(int x, int y, int w, int h, const unsigned char *data) {
    int line, word;
    int words_per_line = (w + 15) / 16;
    
    for (line = 0; line < h; line++) {
        if (y + line < 0 || y + line >= SCREEN_HEIGHT) continue;
        
        int screen_offset = (y + line) * 160;
        int data_offset = line * words_per_line * 8;
        int start_word = x / 16;
        
        for (word = 0; word < words_per_line; word++) {
            int word_x = start_word + word;
            if (word_x < 0 || word_x >= 20) continue;
            
            int buf_offset = screen_offset + word_x * 8;
            int dat_offset = data_offset + word * 8;
            
            /* 4개의 비트플레인 복사 (각 워드당 8바이트) */
            /* 투명도 처리: 데이터가 0이 아닐 때만 복사 */
            unsigned short plane0 = (data[dat_offset + 0] << 8) | data[dat_offset + 1];
            unsigned short plane1 = (data[dat_offset + 2] << 8) | data[dat_offset + 3];
            unsigned short plane2 = (data[dat_offset + 4] << 8) | data[dat_offset + 5];
            unsigned short plane3 = (data[dat_offset + 6] << 8) | data[dat_offset + 7];
            
            /* 마스크: 모든 플레인의 OR */
            unsigned short mask = plane0 | plane1 | plane2 | plane3;
            
            if (mask != 0) {
                /* 기존 버퍼의 해당 위치를 마스크로 지우고 새 데이터 복사 */
                unsigned short *buf = (unsigned short *)&buffer[buf_offset];
                
                buf[0] = (buf[0] & ~mask) | plane0;
                buf[1] = (buf[1] & ~mask) | plane1;
                buf[2] = (buf[2] & ~mask) | plane2;
                buf[3] = (buf[3] & ~mask) | plane3;
            }
        }
    }
}

void drawChar(int x, int y, char c) {
    int line, bit;
    unsigned char pattern;
    
    for (line = 0; line < 8; line++) {
        pattern = font_data[(int)c][line];
        for (bit = 0; bit < 8; bit++) {
            if (pattern & (0x80 >> bit)) {
                int px = x + bit;
                int py = y + line;
                if (px >= 0 && px < SCREEN_WIDTH && py >= 0 && py < SCREEN_HEIGHT) {
                    int word = px / 16;
                    int bitpos = 15 - (px % 16);
                    int offset = py * 160 + word * 8;
                    
                    unsigned short mask = (1 << bitpos);
                    unsigned short *buf = (unsigned short *)&buffer[offset];
                    
                    /* 흰색 (모든 플레인 1) */
                    buf[0] |= mask;
                    buf[1] |= mask;
                    buf[2] |= mask;
                    buf[3] |= mask;
                }
            }
        }
    }
}

void drawText(int x, int y, const char *text) {
    int i = 0;
    while (text[i] != '\0') {
        drawChar(x + i * 8, y, text[i]);
        i++;
    }
}

void drawTextCentered(int y, const char *text) {
    int len = 0;
    while (text[len] != '\0') len++;       // 문자열 길이 계산
    int textWidth = len * 8;               // 1글자 폭 8px
    int x = (SCREEN_WIDTH - textWidth) / 2; // 중앙 x좌표 계산

    for (int i = 0; i < len; i++) {
        drawChar(x + i * 8, y, text[i]);
    }
}

void drawBox(int x, int y, int w, int h) {
    int i, j;
    for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
            if (i == 0 || i == h-1 || j == 0 || j == w-1) {
                int px = x + j;
                int py = y + i;
                if (px >= 0 && px < SCREEN_WIDTH && py >= 0 && py < SCREEN_HEIGHT) {
                    int word = px / 16;
                    int bitpos = 15 - (px % 16);
                    int offset = py * 160 + word * 8;
                    
                    unsigned short mask = (1 << bitpos);
                    unsigned short *buf = (unsigned short *)&buffer[offset];
                    
                    buf[0] |= mask;
                    buf[1] |= mask;
                    buf[2] |= mask;
                    buf[3] |= mask;
                }
            }
        }
    }
}

void initGame() {
    int i;
    player.x = SCREEN_WIDTH / 2 - PLAYER_W / 2;
    player.y = SCREEN_HEIGHT - PLAYER_H - 10;
    
    for (i = 0; i < MAX_BLOCKS; i++) {
        blocks[i].active = 0;
    }
    score = 0;
    frameCount = 0;
}

void spawnBlock() {
    int i;
    for (i = 0; i < MAX_BLOCKS; i++) {
        if (!blocks[i].active) {
            blocks[i].x = (rand() % (SCREEN_WIDTH - BLOCK_W));
            blocks[i].y = -BLOCK_H;
            blocks[i].active = 1;
            break;
        }
    }
}

int checkCollision(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
}

void updateGame() {
    int i;
    
    frameCount++;
    
    if (frameCount % 30 == 0) {
        spawnBlock();
    }
    
    for (i = 0; i < MAX_BLOCKS; i++) {
        if (blocks[i].active) {
            blocks[i].y += BLOCK_SPEED;
            
            if (blocks[i].y > SCREEN_HEIGHT) {
                blocks[i].active = 0;
                score++;
            }
            
            if (checkCollision(player.x, player.y, PLAYER_W, PLAYER_H,
                             blocks[i].x, blocks[i].y, BLOCK_W, BLOCK_H)) {
                gameState = STATE_GAMEOVER;
            }
        }
    }
}

void drawGame() {
    int i;
    char scoreText[20];
    
    clearBuffer();
    
    drawPlanarSprite(player.x, player.y, PLAYER_W, PLAYER_H, player_data);
    
    for (i = 0; i < MAX_BLOCKS; i++) {
        if (blocks[i].active) {
            drawPlanarSprite(blocks[i].x, blocks[i].y, BLOCK_W, BLOCK_H, block_data);
        }
    }
    
    sprintf(scoreText, "SCORE: %d", score);
    drawText(10, 10, scoreText);
    
    swapBuffers();
}
// 한 글자를 2배 크기로 그리기
void drawChar2x(int x, int y, char c) {
    int line, bit, px, py;
    unsigned char pattern;

    for (line = 0; line < 8; line++) {
        pattern = font_data[(int)c][line];
        for (bit = 0; bit < 8; bit++) {
            if (pattern & (0x80 >> bit)) {
                // 2배 확대: 가로, 세로 모두 2배
                for (py = 0; py < 2; py++) {
                    for (px = 0; px < 2; px++) {
                        int draw_x = x + bit*2 + px;
                        int draw_y = y + line*2 + py;
                        if (draw_x >= 0 && draw_x < SCREEN_WIDTH && draw_y >= 0 && draw_y < SCREEN_HEIGHT) {
                            int word = draw_x / 16;
                            int bitpos = 15 - (draw_x % 16);
                            int offset = draw_y * 160 + word*8;
                            unsigned short mask = (1 << bitpos);
                            unsigned short *buf = (unsigned short *)&buffer[offset];
                            buf[0] |= mask;
                            buf[1] |= mask;
                            buf[2] |= mask;
                            buf[3] |= mask;
                        }
                    }
                }
            }
        }
    }
}

// 문자열 전체를 2배 크기로 그리기
void drawText2x(int x, int y, const char *s) {
    int i = 0;
    while (s[i] != '\0') {
        drawChar2x(x + i*16, y, s[i]);  // 8px*2 = 16px
        i++;
    }
}
/* 문자열을 중앙 정렬하여 2배 크기로 그리기 */
void drawText2xCentered(int y, const char *s) {
    int len = strlen(s);
    int x = (320 - len * 16) / 2;  // 글자 폭 16 = 8px × 2
    drawText2x(x, y, s);
}

// drawTextCenteredInBox(x, y, w, h, text)
// x, y : 박스의 왼쪽 상단 좌표
// w, h : 박스 폭과 높이
// text : 표시할 문자열
void drawTextCenteredInBox(int x, int y, int w, int h, const char *text) {
    int len = 0;
    while (text[len] != '\0') len++;          // 문자열 길이 계산

    int textWidth = len * 8;                  // 1글자 폭 8px
    int textHeight = 8;                        // 글자 높이 8px

    int textX = x + (w - textWidth) / 2;      // 가로 중앙
    int textY = y + (h - textHeight) / 2;     // 세로 중앙

    for (int i = 0; i < len; i++) {
        drawChar(textX + i * 8, textY, text[i]);
    }
}

void drawIntroScreen() {
    clearBuffer();

    drawTextCentered(40, "STRAWBERRY ESCAPE!");

    // 각 문장마다 박스를 그리고 중앙 정렬
    const char *lines[] = {
        "1. Avoid falling strawberries.",
        "2. Move with LEFT and RIGHT keys.",
        "3. Survive as long as possible."
    };

    int startY = 80;
    for (int i = 0; i < 3; i++) {
        int len = 0;
        while (lines[i][len] != '\0') len++;
        int textWidth = len * 8; // 1글자 폭 8px
        int x = (SCREEN_WIDTH - textWidth) / 2;
        int y = startY + i * 30; // 줄 간격 30px

        // 텍스트 박스 그리기
        drawBox(x - 4, y - 4, textWidth + 8, 16); // 8px 높이, 여백 4px

        // 텍스트 그리기
        drawText(x, y, lines[i]);
    }

    // START 버튼
    const char *startText = "Press SPACE to START";
    int len = 0;
    while (startText[len] != '\0') len++;
    int textWidth = len * 8;
    int x = (SCREEN_WIDTH - textWidth) / 2;
    int y = startY + 3 * 30;

    drawBox(x - 4, y - 4, textWidth + 8, 16);
    drawText(x, y, startText);

    swapBuffers();
}

void drawStartScreen() {
    clearBuffer();

    /* 큰 제목 중앙 정렬 */
    drawText2xCentered(60, "STRAWBERRY ESCAPE");

    /* 버튼 */
    drawBox(110, 130, 100, 30);
    drawTextCentered(140, "START");

    swapBuffers();
}


void drawGameOverScreen() {
    clearBuffer();

    /* Game Over 이미지 흔들기 */
    int shake = (rand() % 3) - 1;  // -1, 0, 1
    drawPlanarSprite(
        (320 - GAMEOVER_W) / 2 + shake,
        40,
        GAMEOVER_W,
        GAMEOVER_H,
        gameover_data
    );

    /* 텍스트 */
    drawText2x(90, 110, "GAME OVER");

    /* Restart 버튼 */
    drawBox(60, 140, 100, 30);       // 왼쪽 버튼
    drawTextCenteredInBox(60, 140, 100, 30, "RESTART");

    /* Credit 버튼 */
    drawBox(180, 140, 100, 30);      // 오른쪽 버튼
    drawTextCenteredInBox(180, 140, 100, 30, "CREDIT");  // 문자열과 괄호 닫기

    swapBuffers();
}

void drawCreditScreen() {
    clearBuffer();

    drawTextCentered(60, "Seoyul Lee");
    drawTextCentered(80, "3DVG DAD");
    drawTextCentered(100, "ESAD Orleans 2025");

    drawTextCentered(160, "Press SPACE to return to START");

    swapBuffers();
}


int main() {
    int running = 1;
    long key;

    physScreen = (unsigned char *)Physbase();

    savePalette();
    setupGamePalette();

    srand(Gettime());
    Cconws("\033E\033f");

    gameState = STATE_INTRO;  // 초기 상태를 INTRO로
    initGame();

    while (running) {
        if (gameState == STATE_INTRO) {
            drawIntroScreen();
            Vsync();

            if (Cconis()) {
                key = Cnecin();
                if ((key & 0xFF) == ' ' || (key & 0xFF) == 0x0D) {
                    gameState = STATE_START;
                }
            }

        } else if (gameState == STATE_START) {
            drawStartScreen();
            Vsync();

            if (Cconis()) {
                key = Cnecin();
                if ((key & 0xFF) == ' ' || (key & 0xFF) == 0x0D) {
                    gameState = STATE_PLAYING;
                    initGame();
                }
            }

        } else if (gameState == STATE_PLAYING) {
            if (Cconis()) {
                key = Cnecin();

                if ((key >> 16) == 0x4B) {  // LEFT
                    player.x -= 5;
                    if (player.x < 0) player.x = 0;
                } else if ((key >> 16) == 0x4D) { // RIGHT
                    player.x += 5;
                    if (player.x > SCREEN_WIDTH - PLAYER_W) 
                        player.x = SCREEN_WIDTH - PLAYER_W;
                } else if ((key & 0xFF) == 0x1B) { // ESC
                    running = 0;
                }
            }

            updateGame();
            drawGame();
            Vsync();

        } else if (gameState == STATE_GAMEOVER) {
            drawGameOverScreen();
            Vsync();

            if (Cconis()) {
                key = Cnecin();
                if ((key & 0xFF) == ' ' || (key & 0xFF) == 0x0D) {
                    gameState = STATE_PLAYING;  // RESTART
                    initGame();
                } else if ((key & 0xFF) == 'c' || (key & 0xFF) == 'C') {
                    gameState = STATE_CREDIT;   // CREDIT
                }
            }

        } else if (gameState == STATE_CREDIT) {
            drawCreditScreen();
            Vsync();

            if (Cconis()) {
                key = Cnecin();
                if ((key & 0xFF) == 0x1B) { // ESC 누르면 종료
                    running = 0;
                }
            }
        }
    }

    restorePalette();
    Cconws("\033E");

    return 0;
}